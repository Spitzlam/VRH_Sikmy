<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VRHY — mini program pro vizualizaci a výpočet vrhů</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;display:flex;gap:20px;padding:20px}
    .panel{width:340px}
    label{display:block;margin-top:10px}
    canvas{background:#f8f9fb;border:1px solid #ddd}
    .values{margin-top:10px}
    button{margin-top:12px;padding:8px 12px;border-radius:8px}
    .small{font-size:90%;color:#444}
  </style>
</head>
<body>
  <div class="panel">
    <h2>VRHY — vizualizace</h2>

    <label>Rychlost v (m/s)
      <input id="v" type="number" value="30" min="0" step="0.1">
    </label>
    <label>Úhel θ (stupně)
      <input id="theta" type="number" value="35" min="0" max="89.9" step="0.1">
    </label>
    <label>Počáteční výška h (m)
      <input id="h" type="number" value="1.5" min="-100" step="0.1">
    </label>
    <label>Gravitace g (m/s²)
      <input id="g" type="number" value="9.81" min="0.1" step="0.01">
    </label>

    <button id="drawBtn">Vykreslit šikmý vrh</button>
    <button id="optBtn">Najít optimální úhel</button>
    <button id="verticalBtn">Vykreslit svislý vrh</button>
    <button id="resetBtn">Reset</button>

    <div class="values">
      <div>Max výška: <span id="ymax">—</span> m</div>
      <div>Dopad (vzdálenost): <span id="range">—</span> m</div>
      <div>Čas letu: <span id="tflight">—</span> s</div>
      <div>Optimální úhel: <span id="thetaOpt">—</span> °</div>
    </div>
    <p class="small">Měřítko: mřížka po 5 metrech</p>
  </div>

  <div>
    <canvas id="c" width="820" height="480"></canvas>
  </div>

<script>
const toRad = d => d*Math.PI/180;
const toDeg = r => r*180/Math.PI;

function computeFlightTime(v,th,h,g){
  const a=-0.5*g,b=v*Math.sin(th),c=h;
  const D=b*b-4*a*c; if(D<0)return null;
  const t1=(-b+Math.sqrt(D))/(2*a);
  const t2=(-b-Math.sqrt(D))/(2*a);
  return Math.max(t1,t2);
}

function computeMaxHeight(v,th,h,g){const vy=v*Math.sin(th);return h+vy*vy/(2*g);} 
function computeRange(v,th,h,g){const t=computeFlightTime(v,th,h,g);return t?v*Math.cos(th)*t:0;}

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const PX_PER_M = 5;
const GRID_STEP_M = 5;

function clearCanvas(){ctx.clearRect(0,0,canvas.width,canvas.height);}

function drawGrid(maxX,maxY){
  ctx.save(); ctx.translate(0,canvas.height); ctx.scale(1,-1);
  ctx.strokeStyle='#ddd'; ctx.lineWidth=1;

  for(let x=0;x<=maxX;x+=GRID_STEP_M){
    ctx.beginPath();
    ctx.moveTo(x*PX_PER_M,0);
    ctx.lineTo(x*PX_PER_M,maxY*PX_PER_M);
    ctx.stroke();
  }
  ctx.restore();
}

function drawTrajectoryFull(v,thetaDeg,h,g,opt={color:'#0074D9'}){
  const th = toRad(thetaDeg);
  const tF = computeFlightTime(v,th,h,g);
  const pts=[]; let xmax=0,ymax=0;

  for(let i=0;i<=500;i++){
    const t=tF*i/500;
    let x=v*Math.cos(th)*t;
    let y=h+v*Math.sin(th)*t-0.5*g*t*t;
    if(y<0) y=0;
    pts.push([x,y]);
    if(x>xmax)xmax=x;
    if(y>ymax)ymax=y;
  }

  ctx.save(); ctx.translate(0,canvas.height); ctx.scale(1,-1);
  ctx.beginPath(); ctx.lineWidth=3; ctx.strokeStyle=opt.color;

  pts.forEach(([x,y],i)=>{
    const X=x*PX_PER_M, Y=y*PX_PER_M;
    if(i===0) ctx.moveTo(X,Y);
    else ctx.lineTo(X,Y);
  });

  ctx.stroke(); ctx.restore();
  return {xmax,ymax};
}

function render(){
  const v=parseFloat(vEl.value);
  const th=parseFloat(thetaEl.value);
  const h=parseFloat(hEl.value);
  const g=parseFloat(gEl.value);

  clearCanvas();
  const r = drawTrajectoryFull(v,th,h,g);
  drawGrid(r.xmax,r.ymax);
  drawTrajectoryFull(v,th,h,g);

  ymaxEl.textContent = computeMaxHeight(v,toRad(th),h,g).toFixed(2);
  rangeEl.textContent = computeRange(v,toRad(th),h,g).toFixed(2);
  tflightEl.textContent = computeFlightTime(v,toRad(th),h,g).toFixed(2);
}

function maximizeAngle(v,h,g){
  let a=1e-6,b=Math.PI/2-1e-6;
  for(let i=0;i<80;i++){
    const m=(a+b)/2;
    const left=computeRange(v,a,h,g);
    const mid=computeRange(v,m,h,g);
    if(mid>left) a=m; else b=m;
  }
  return (a+b)/2;
}

document.getElementById('optBtn').onclick = ()=>{
  const v=parseFloat(vEl.value),h=parseFloat(hEl.value),g=parseFloat(gEl.value);
  const thOpt = toDeg(maximizeAngle(v,h,g));
  thetaOptEl.textContent = thOpt.toFixed(2);

  clearCanvas();
  const r = drawTrajectoryFull(v,thOpt,h,g,{color:'#FF4136'});
  drawGrid(r.xmax,r.ymax);
  drawTrajectoryFull(v,thOpt,h,g,{color:'#FF4136'});

  ymaxEl.textContent = computeMaxHeight(v,toRad(thOpt),h,g).toFixed(2);
  rangeEl.textContent = computeRange(v,toRad(thOpt),h,g).toFixed(2);
  tflightEl.textContent = computeFlightTime(v,toRad(thOpt),h,g).toFixed(2);
};

document.getElementById('verticalBtn').onclick = () => {
  const v=parseFloat(vEl.value);
  const h=parseFloat(hEl.value);
  const g=parseFloat(gEl.value);

  clearCanvas();

  const tTop=v/g;
  const tTotal=tTop*2;
  const pts=[];
  let maxY=0;

  for(let i=0;i<=500;i++){
    const t=tTotal*i/500;
    let y=h+v*t-0.5*g*t*t;
    if(y<0) y=0;
    pts.push([t,y]);
    if(y>maxY) maxY=y;
  }

  drawGrid(tTotal*8,maxY);

  ctx.save(); ctx.translate(0,canvas.height); ctx.scale(1,-1);
  ctx.beginPath(); ctx.lineWidth=3; ctx.strokeStyle='#AA00FF';

  pts.forEach(([t,y],i)=>{
    const X=t*80;
    const Y=y*PX_PER_M;
    if(i===0) ctx.moveTo(X,Y);
    else ctx.lineTo(X,Y);
  });

  ctx.stroke(); ctx.restore();

  ymaxEl.textContent = (v*v/(2*g)+h).toFixed(2);
  rangeEl.textContent = "0";
  tflightEl.textContent = tTotal.toFixed(2);
  thetaOptEl.textContent = "—";
};

const vEl=document.getElementById('v');
const thetaEl=document.getElementById('theta');
const hEl=document.getElementById('h');
const gEl=document.getElementById('g');
const ymaxEl=document.getElementById('ymax');
const rangeEl=document.getElementById
</script>
</body>
</html>